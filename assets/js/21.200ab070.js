(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{413:function(e,n,t){"use strict";t.r(n);var a=t(17),s=Object(a.a)({},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("公司之前的vue项目用的webpack3.x，觉得自己对webpack也有了一定经验，于是开始了试试之旅")]),e._v(" "),t("p",[e._v("webpack升级到4.x的更新，是有很多大改动的，也有一些平滑的升级，那么下面我开始介绍了")]),e._v(" "),t("ol",[t("li",[e._v("webpack升级到4.x后，把核心代码和客户端分离开了，所以同时也必须要依赖webpack-cli这个包")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("yarn add webpack-cli --dev\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("webpack升级后，导致plugin机制也跟着一起变化了，因此插件包也需要升级")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("yarn add html-webpack-plugin — dev\n")])])]),t("p",[e._v("webpack 3.X用于打包css的插件extract-text-webpack-plugin，不能在4中使用，所以经过有两个方法可以解决")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 方法一 extract-text-webpack-plugin 包有个为了webpack4.x单独开发了个next版本\nyarn add html-webpack-plugin@next —dev\n// 方法二 用新的打包css包 mini-css-extract-plugin\nyarn add mini-css-extract-plugin —dev\n// mini-css-extract-plugin使用方法\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nmodule: {\n  rules: [\n    {\n      test: /\\.less$/,\n      use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader']\n    },\n    {\n      test: /\\.css$/,\n      use: [MiniCssExtractPlugin.loader, 'css-loader']\n    },\n  ]\n}\n// loder的运行机制是从右到左的，所以需要在css-loader之后再加上打包css操作。\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[e._v("webpack4.x的mode是必填项\nmode分development（开发环境） 和 production（生产环境），webpack对不同的环境也不同的默认操作。\n"),t("br")])]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[e._v("选项")]),e._v(" "),t("th",{staticStyle:{"text-align":"left"}},[e._v("描述")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("development")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("启用 NamedChunksPlugin 和 NamedModulesPlugin")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("production")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[e._v("启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin（tree-shaking） 和 UglifyJsPlugin（压缩代码）")])])])]),e._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[e._v("webpack4.x也废弃了一些之前的插件")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("废弃插件：UglifyjsWebpackPlugin\n"),t("br"),e._v("\nmode 为production时，默认开启。")])]),e._v(" "),t("li",[t("p",[e._v("ModuleConcatenationPlugin\n新增属性：concatenateModules")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 配置\nmodule.exports = {\n  //...\n  optimization: {\n    concatenateModules: true\n  }\n};\n//开启前\n[\n    /* 0 */\n    function(module, exports, require) {\n        var module_a = require(1)\n        console.log(module_a['default'])\n    }\n    \n    /* 1 */\n    function(module, exports, require) {\n        exports['default'] = 'module A'\n    }\n]\n//开启后\n[\n    function(module, exports, require) {\n        var module_a_defaultExport = 'module A'\n        console.log(module_a_defaultExport)\n    }\n]\n")])])]),t("p",[e._v("concatenateModules开启之后，可以看出bundle文件中的函数声明变少了，因而可以带来的好处，其一，文件的体积比之前更小了，其二，运行代码时创建的函数作用域变少了，开销也随之变少了。")])]),e._v(" "),t("li",[t("p",[e._v("废弃插件：CommonsChunkPlugin\n"),t("br"),e._v("\n新增属性：splitChunks\n"),t("br")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('optimization: {\n  splitChunks: {\n    chunks: "initial",         // 必须三选一： "initial" | "all"(默认就是all) | "async"\n    minSize: 0,                // 最小尺寸，默认0\n    minChunks: 1,              // 最小 chunk ，默认1\n    maxAsyncRequests: 1,       // 最大异步请求数， 默认1\n    maxInitialRequests: 1,    // 最大初始化请求书，默认1\n    name: () => {},              // 名称，此选项课接收 function\n    cacheGroups: {                 // 这里开始设置缓存的 chunks\n      priority: "0",                // 缓存组优先级 false | object |\n      vendor: {                   // key 为entry中定义的 入口名称\n        chunks: "initial",        // 必须三选一： "initial" | "all" | "async"(默认就是异步)\n        test: /react|lodash/,     // 正则规则验证，如果符合就提取 chunk\n        name: "vendor",           // 要缓存的 分隔出来的 chunk 名称\n        minSize: 0,\n        minChunks: 1,\n        enforce: true,\n        maxAsyncRequests: 1,       // 最大异步请求数， 默认1\n        maxInitialRequests: 1,    // 最大初始化请求书，默认1\n        reuseExistingChunk: true   // 可设置是否重用该chunk（查看源码没有发现默认值）\n      }\n    }\n  }\n},\n')])])]),t("p",[e._v("chunks在设置的尽量不要设置成async（异步），我在打包时测试，如果选异步会导致生成文件偏大，我猜测是因为在打包多个vendor时异步就很难通知别的vendor某个包已被打包了，导致重复打包。")])])]),e._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[e._v("说了那么多变化大，那么webpack平滑升级操作有吗？答案是当然有的。\n"),t("br"),e._v("\n比如 module.loaders 替换为 modules.rules\n在webpack3.x的时候module就可以使用module.rules")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module: {\n  rules: [\n    ...\n  ]\n}\n")])])]),t("ol",{attrs:{start:"6"}},[t("li",[e._v("以上对针对webpack配置的升级，那么自己的项目在本次升级有什么问题呢？")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Module parse failed: Unexpected character '#' (16:0) You may need an appropriate loader to handle this file type.")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const VueLoaderPlugin = require('vue-loader/lib/plugin’)\nplugins: [\n  // 请确保引入这个插件！\n  new VueLoaderPlugin()\n]\n")])])]),t("ul",[t("li",[t("code",[e._v('Module build failed (from ./node_modules/postcss-loader/src/index.js): Error: Cannot load preset "advanced". Please check your configuration for errors and try again')])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("yarn add cssnano-preset-advanced --dev\n")])])]),t("ul",[t("li",[t("code",[e._v("XXX already has a 'content' property, give up to overwrite it.")]),e._v("\n在自己项目css中有使用after的content，会被打包库打包")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\"postcss-viewport-units\": {\n  filterRule: rule => rule.nodes.findIndex(i => i.prop === 'content') === -1\n},\n")])])]),t("ul",[t("li",[t("code",[e._v("TypeError: Cannot read property 'eslint' of undefined")]),e._v("\neslint-loader 2.0以上")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("yarn add eslint-loader --dev\n")])])]),t("ol",{attrs:{start:"7"}},[t("li",[e._v("对项目文件存放的理解，vue脚手架工具会有生成static文件夹和assets文件夹\n之前项目在开发中也有草莽之处，就是放静态文件全都放到static文件夹中。从现在自己的知识角度来看，才发现这是个很大的错误。\n"),t("br"),e._v("\n首先讲下是什么导致static文件夹和asset文件夹有所不同的")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new CopyWebpackPlugin([\n  {\n    from: path.resolve(__dirname, '../static'),\n    to: config.build.assetsSubDirectory,\n    ignore: ['.*']\n  }\n])\n")])])]),t("p",[e._v("正是因为这段webpack的配置导致这两个文件夹有所不同。那么这两个文件夹的作用是什么呢\n"),t("br"),e._v("\n先说个人结论吧，static文件夹适合放那些不能被webpack进行模块和资源的转换的文件，而assets文件夹更适合能被webpack进行模块和资源的转换的文件。\n"),t("br"),e._v("\n那么什么样的文件能做进行模块和资源的转换？\n"),t("br"),e._v("\n比如说： img的src是相对路径（'../image.png'）, 或者是background: url(../image.png),亦或者是img: require('../image.png')，代码在被webpack解析的时候，将被视为webpack的模块依赖。被视为模块依赖，就会走webpack的loader操作，那么这些静态不需要被拷贝到dist文件夹下，他有可能被loader转化成base64，也有可能经过处理被输出到dist文件下，所以并不需要被拷贝到dist文件夹下。")]),e._v(" "),t("h2",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#","aria-hidden":"true"}},[e._v("#")]),e._v(" "),t("br")]),e._v(" "),t("p",[e._v("综上是我总结--")])])},[],!1,null,null,null);n.default=s.exports}}]);