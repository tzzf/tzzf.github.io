(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{398:function(t,e,n){"use strict";n.r(e);var a=n(17),l=Object(a.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("一道题目引发的思考")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  let spaceship = {\n    homePlanet : 'Earth',\n    color : 'red'\n  };\n  let tryReassignment = obj => {\n    obj = {\n    identified : false, \n    'transport type' : 'flying'\n    }\n    console.log(obj) // {'identified': false, 'transport type': 'flying'}\n  };\n  tryReassignment(spaceship)\n  console.log(spaceship) // {homePlanet: \"Earth\", color: \"red\"}\n")])])]),n("p",[t._v("为什么在函数内改变参数的值，看上去改变成功，但其实并没有改变成功。\n"),n("br"),t._v("\n那么从头开始讲这是为什么？")]),t._v(" "),n("blockquote",[n("p",[t._v("JavaScript有5种基本的数据类型，分别是：布尔、null、undefined、String和Number，还有引用类型值，分别是 Array、Function和Object。\n"),n("br"),t._v("\n这俩种数据类型在值绑定的过程区别是很大的，像基本数据类型，在变量赋值过程中就是讲这个值绑定到这个变量上，但是引用类型值则不同，它是讲这个值所对应的内存地址绑定给这个变量。这种不同的赋值方式分别叫值传递和引用传递。\n"),n("br"),t._v("\n下面用表格的方式来描述下")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var obj = {}; // 步骤一\nobj.val = 'value'; // 步骤二\nvar newObj = obj; // 步骤三\n")])])]),n("p",[t._v("// 步骤一时")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"center"}},[t._v("变量")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("地址")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("值")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("obj")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("#001")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("{}")])])])]),t._v(" "),n("p",[t._v("// 步骤二时")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"center"}},[t._v("变量")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("地址")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("值")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("obj")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("#001")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("{val: 'value'}")])])])]),t._v(" "),n("p",[t._v("// 步骤三时")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"center"}},[t._v("变量")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("地址")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("值")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("obj")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("#001")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("{val: 'value'}")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("newObj")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("#001")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})])])]),t._v(" "),n("p",[t._v("可以看出obj的地址时一直没变的，当obj被赋值给另一个变量时它只是将地址传递给另一个变量，这就是引用传递。\n"),n("br"),t._v("\n明白了引用传递和值传递，那么你就会这两个和上面的题目有上面关系呢？下面就开始讲讲两者的关系。\n"),n("br"),t._v("\nJS函数的参数与大多数其他语言中函数的参数有所不同，JS函数不介意传递进来多少个参数，也不在乎传递进来的参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数也未必一定要传递两个参数。可以传递一个，三个甚至不传递参数，而解析器永远也不会有什么怨言。原因是JavaScript中的参数在内部是用一个数组来表示的。**函数接受到始终是这个数组，而不关心数组包含多少元素和参数。**实际上在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。\n"),n("br"),t._v("\njs是数组类型来接受参数，那么下面就画个上面题目的示意图：")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"center"}},[t._v("变量")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("地址")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("值")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("spaceship")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("#001")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v('{homePlanet: "Earth", color: "red"}')])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("obj（参数）")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("#001")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}})])])]),t._v(" "),n("p",[t._v("在函数内部，obj进行一次变量赋值，obj是对象类型，因为是引用传递，所以将obj的地址换了一个新的地址")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"center"}},[t._v("变量")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("地址")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("值")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("obj（参数）")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("#002")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("{'identified': false, 'transport type': 'flying'}")])])])]),t._v(" "),n("p",[t._v("但是由于是地址更换了，并未对之前地址的值对修改，所以未改变传的值。\n"),n("br"),t._v("\n当然有人觉得传值也是可以理解的，因为值被赋值到了另一个对象里而已，那么怎么证明是传的是地址呢？下面再出一题改的是地址的值")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var a = {\n    key: 'name',\n    value: 2121\n}\nvar handleValue = (obj) => {\n    obj.key = 'otherKey';\n    console.log(obj); // {key: \"otherKey\", value: 2121}\n}\nhandleValue(a);\nconsole.log(a); // {key: \"otherKey\", value: 2121}\n")])])]),n("p",[t._v('这题中handleValue函数参数传的是{key: "name", value: 2121}的地址，在函数内部将改地址对应的值修改了，所以最开始定义的变量也被修改了\n'),n("br"),t._v("\n那么我们也可以开始实验，将参数的地址换一个而不是之前的a所对应的地址，那么怎么修改呢？当然是用深拷贝啊。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function deepCopy (source) {\n  const result = source.constructor === Array ? [] : {}; // 用三目运算判断他是数组还是对象\n  for (const key in source) {\n    if (typeof source[key] === 'object') {\n      result[key] = deepCopy(source[key]);\n    } else {\n      result[key] = source[key];\n    }\n  }\n  return result;\n};\nvar a = {\n    key: 'name',\n    value: 2121\n}\nvar handleValue = (obj) => {\n    console.log(obj); // {key: \"name\", value: 2121}\n    obj.key = 'otherKey';\n    console.log(obj); // {key: \"otherKey\", value: 2121}\n}\nhandleValue(deepCopy(a));\nconsole.log(a); // {key: \"name\", value: 2121}\n")])])]),n("p",[t._v("a并没有修改，但是在函数内部的参数obj已经被修改，正是说明参数obj所对应的地址已被修改，只是这次obj对应的地址并不是和之前的a所对应的地址一样了。")])])},[],!1,null,null,null);e.default=l.exports}}]);