(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{380:function(n,e,t){n.exports=t.p+"assets/img/flutter(4)1.17d270b2.png"},403:function(n,e,t){"use strict";t.r(e);var a=t(17),r=Object(a.a)({},function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("flutter dio封装")]),n._v(" "),a("h2",{attrs:{id:"痛点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#痛点","aria-hidden":"true"}},[n._v("#")]),n._v(" 痛点")]),n._v(" "),a("p",[n._v("使用app的过程中，接口的请求是必不可少的。为了在开发高效，我当然要尝试封装dio插件。在最近的多个app开发中，尝试多种封装的方法，于是乎就得出啦一下的一套方法。")]),n._v(" "),a("h2",{attrs:{id:"封装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装","aria-hidden":"true"}},[n._v("#")]),n._v(" 封装")]),n._v(" "),a("p",[n._v("在封装之前，需要确定我们需要那些需求。")]),n._v(" "),a("ol",[a("li",[n._v("部分接口的请求过程中需要一个loading来表示这个接口正在请求中。")]),n._v(" "),a("li",[n._v("接口要可以抛出异常的toast")]),n._v(" "),a("li",[n._v("不同的接口有不同的请求方法，不同的contentType")]),n._v(" "),a("li",[n._v("对响应请求的统一处理")])]),n._v(" "),a("br"),n._v("\n那么先上满足以上的简陋版本\n"),a("br"),n._v(" "),a("p",[n._v("安装插件")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('dio: "^3.0.9"\nflutter_easyloading: ^1.1.2\n')])])]),a("br"),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("import 'dart:collection';\nimport 'package:dio/dio.dart';\nimport 'package:flutter_easyloading/flutter_easyloading.dart';\nimport 'package:testmuban/constant/constant.dart';\nclass _Service {\n  _Service() {\n    _initDio();\n  }\n  Dio _dio = new Dio();\n  static String token;\n  void setToken(String tk) {\n    token = tk;\n  }\n\n  void _initDio () {\n    // 接口日志\n    _dio.interceptors.add(LogInterceptor(responseBody: true, requestBody: true));\n    _dio.interceptors.add(InterceptorsWrapper(\n        onRequest: (RequestOptions options){\n          // 超时时间\n          options.connectTimeout = 3000;\n          // 在请求被发送之前做一些事情\n          return options;\n        },\n        onResponse: (Response response) {\n          // 在返回响应数据之前做一些预处理\n          if (response.data['code'] != '200') {\n            EasyLoading.showError('Failed with Error',duration: Duration(seconds: 3));\n          }\n          return response;\n        },\n        onError: (DioError error) {\n          // 当请求失败时做一些预处理\n          EasyLoading.showError('Failed with Error',duration: Duration(seconds: 3));\n          return error;\n        },\n    ));\n  }\n  // 真正发请求的地方\n  Future fetch(url, {\n      dynamic params,\n      Map<String, dynamic> header,\n      Options option,\n      bool isShowLoading = false\n    }) async{\n    Map<String, dynamic> headers = new HashMap(\n    );\n    headers['Authorization'] =  token;\n    if (header != null) {\n      headers.addAll(header);\n    }\n    if (option != null) {\n      option.headers = headers;\n    } else {\n      option = new Options(method: \"get\");\n      option.headers = headers;\n    }\n    // 是否需要 loading\n    if (isShowLoading) {\n      EasyLoading.show(status: 'loading...'); \n    }\n    try {\n      // 发送请求获取结果\n      Response _response = await _dio.request('${Constant.baseUrl}$url', data: params, options: option);\n      // 返回真正结果\n      return _response;\n    } catch (error) {\n      // 异常提示\n      EasyLoading.dismiss();\n    } finally {\n      // 不管结果怎么样 都需要结束Loading\n      EasyLoading.dismiss();\n    }\n  }\n}\nfinal _Service service = new _Service();\n\n")])])]),a("p",[n._v("接下来是使用这个封装的")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("import 'package:dio/dio.dart';\nimport 'package:testmuban/constant/constant.dart';\nimport 'package:testmuban/service/service.dart';\nclass Api {\n  // 获取用户信息\n  static Function get getBasketball => () => service.fetch('onebox/basketball/nba?key=${Constant.juheKey}', isShowLoading: true);\n\n  // static Function get login => (param) => service.fetch('login', params: param, isShowLoading: true, option: new Options(method: \"post\"));\n\n}\n\n")])])]),a("p",[n._v("这里各位还需要看下"),a("a",{attrs:{href:"http://s0pub0dev.icopy.site/packages/flutter_easyloading",target:"_blank",rel:"noopener noreferrer"}},[n._v("flutter_easyloading的使用教程"),a("OutboundLink")],1),n._v(" "),a("br"),n._v("\n这里我在使用过程中还发现了一个小问题")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("Unhandled Exception: 'package:flutter/src/widgets/overlay.dart': Failed assertion: line 132 pos 12: '_overlay != null': is not true.\n\n")])])]),a("br"),n._v("\n我看源码发现，remove函数会设置_overlay = null, 这里就是因为我请求报错的就会去showError，然后这个又会去走_show方法。_show方法中在渲染之前一定都会去remove，但是因为渲染ui的异步操作，导致中间出现调用了两次remove的情况。\n"),a("br"),n._v(" "),a("img",{staticStyle:{height:"300px"},attrs:{src:t(380)}}),n._v("\n这里的WidgetsBinding.instance.addPostFrameCallback就是异步操作，所以导致在出现了连续两次remove。\n"),a("br"),n._v("\n于是，我就通过在service中添加标识位的方法来避免连续两次remove。\n"),a("br"),n._v("\n以下是我加的代码\n"),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("static bool isToast = false;\nvoid setToast(bool val) {\n  isToast = val;\n}\n\n// 在报错之前设置标识为true\nsetToast(true);\nEasyLoading.showError('Failed with Error',duration: Duration(seconds: 3));\n\n// 不管结果怎么样 都需要结束Loading\nif (isShowLoading && !isToast) {\n  EasyLoading.dismiss();\n} else if (isToast) {\n  setToast(false);\n}\n")])])]),a("p",[n._v("但是这个方法只针对这个工具函数，最终还是需要提下issue或者pr，让owner去将方法改成同步或者添加个标识位判断下。\n"),a("br"),n._v(" "),a("a",{attrs:{href:"https://github.com/tzzf/flutterdio",target:"_blank",rel:"noopener noreferrer"}},[n._v("封装地址"),a("OutboundLink")],1),n._v(" "),a("br")]),n._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),a("p",[n._v("在封装前，先考虑下自己的需求是什么。封装后如果出现来报错也不要慌，一点点看源码，看他们步骤调用了那些函数。以上就是我最近app项目的dio封装总结。")])])},[],!1,null,null,null);e.default=r.exports}}]);