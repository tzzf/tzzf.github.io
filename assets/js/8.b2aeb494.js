(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{388:function(n,e,t){n.exports=t.p+"assets/img/react(2)1.1f082e47.jpg"},389:function(n,e,t){n.exports=t.p+"assets/img/react(2)2.e38ec881.jpg"},406:function(n,e,t){"use strict";t.r(e);var o=t(17),a=Object(o.a)({},function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("p",[n._v("hooks优化你的函数式组件")]),n._v(" "),o("p",[n._v("因为hooks已经被运用到项目中，在多次使用和查阅react文档之后，对其的了解更多深入了一些。故也学会了一些优化小技巧。\n"),o("br"),n._v("\n先讲一下优化点，其实优化点也是部分是从class component类比过来。\n"),o("br"),n._v("\n比如class component是分普通的component还有一种purecomponent。")]),n._v(" "),o("h4",{attrs:{id:"component和purecomponent区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#component和purecomponent区别","aria-hidden":"true"}},[n._v("#")]),n._v(" Component和PureComponent区别")]),n._v(" "),o("p",[n._v("简单的介绍下两者的区别。purecomponent提供了一个具有浅比较的shouldComponentUpdate方法。当props和state的值更改后，purecomponent会自动进行浅比较，若return true，则重新渲染这个jsx。反之，不渲染。\n"),o("br"),n._v("\n那么hooks是怎么实现PureComponent的呢？\n"),o("br"),n._v("\n在查阅文档后，"),o("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-api.html#reactmemo",target:"_blank",rel:"noopener noreferrer"}},[n._v("发现memo可以执行PureComponent的效果"),o("OutboundLink")],1),n._v("。")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("  const MyComponentMemo = React.memo(function MyComponent(props) {\n    /* 使用 props 渲染 */\n  });\n")])])]),o("p",[n._v("这种方法只能适用适用于函数式组件。memo接受的参数不止于一个参数，第一个参数是函数式组件，第二个参数可以是自定义的比较函数，若不传就用他自己的。这里文档中也提示这只是性能优化的方法，不用自定义的的比较函数来阻止函数的渲染，这样容易的产生bug。\n"),o("br"),n._v("\nclass component每次props或者state的更改是重新执行一边render内的函数，那么function component每次props或者useReducer或者useState的更改，因为这个是函数式组件，所以他在更改的时候，函数作用域内的一切都是重新执行。\n"),o("br")]),n._v(" "),o("h4",{attrs:{id:"减少重新定义"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#减少重新定义","aria-hidden":"true"}},[n._v("#")]),n._v(" 减少重新定义")]),n._v(" "),o("p",[n._v("重新执行一遍，你这一听就感觉很消耗性能。那么hooks针对这个有什么性能优化呢？\n"),o("br")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("function Hooks() {\n  const [count, setCount] = useState(1);\n  const [name, setName] = useState(1);\n  const handleClick = () => {\n    setCount(count++);\n  }\n  const handleNameClick = () => {\n    setName(`${name}we`);\n  }\n  return (\n    <div>\n      <div onClick={handleClick}>{count}</div>\n      <div onClick={handleNameClick}>{name}</div>\n    </div>\n  )\n}\n")])])]),o("p",[n._v("上述的函数式组件，在count或者name更改的时候，handleClick和handleNameClick函数都会被重新定义一遍，很消耗性能。\n"),o("br"),n._v("\n那么，你可以把这些函数放到函数式组件外面去，但是这个函数就没有这个函数式组件的作用域了。所以并不是很好的方法。\n"),o("br"),n._v("\n那么hooks了提供了"),o("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback",target:"_blank",rel:"noopener noreferrer"}},[n._v("useCallback"),o("OutboundLink")],1),n._v("。正是为了避免这种性能消耗过多的情况。\n"),o("br"),n._v("\nuseCallback方法可以传两个参数，第一是参数是函数，第二个参数就是这个函数所依赖的数据，当这里的数据变化了，才会去重新定义新的函数。\n"),o("br"),n._v("\n下面就上一下我项目中函数式组件的函数定义的优化的效果。实验过程：在页面渲染完成进行普通tab切换实验，看tab切换的渲染效果如何\n"),o("br"),n._v("\n使用useCallback之前的\n"),o("br"),n._v(" "),o("img",{staticStyle:{height:"200px"},attrs:{src:t(388)}}),n._v(" "),o("br"),n._v("\n使用useCallback之后的\n"),o("br"),n._v(" "),o("img",{staticStyle:{height:"200px"},attrs:{src:t(389)}}),n._v(" "),o("br"),n._v("\n可以看出scripting的时间已经减少了。so，优化效果还是有的。")])])},[],!1,null,null,null);e.default=a.exports}}]);