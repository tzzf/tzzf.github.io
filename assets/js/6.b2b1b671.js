(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{392:function(e,t,s){e.exports=s.p+"assets/img/webpack(2)1.7c2f0679.jpg"},393:function(e,t,s){e.exports=s.p+"assets/img/webpack(2)2.c6978773.jpg"},394:function(e,t,s){e.exports=s.p+"assets/img/webpack(2)3.f64a7d21.jpg"},395:function(e,t,s){e.exports=s.p+"assets/img/webpack(2)4.3108f3d9.jpg"},415:function(e,t,s){"use strict";s.r(t);var a=s(17),n=Object(a.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("一起来看看webpack打包后的文件")]),e._v(" "),a("p",[e._v("bundle是由webpack打包出来的文件(文件束)，那么通过分析bundle文件，我们可以看看代码的模块机制。")]),e._v(" "),a("ol",[a("li",[e._v("运行环境")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("webpack 4.29.3（只有4.X就可以了）\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("webpack的配置")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let path = require('path')\nmodule.exports = {\n    mode: 'development', // webpack mode production 会默认开启开启压缩代码，要分析的话，就不能用这个模式\n    entry: './src/index.js',\n    output: {\n        filename: 'bundle.js',\n        path: path.resolve(__dirname, 'dists'),\n    }\n}\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[e._v("要被打包的文件\n新建src文件夹，在这个文件夹下新建一个a.js和index.js\na.js")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("module.exports = 'demo01'\n")])])]),a("p",[e._v("index.js")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let a = require('./a.js');\n\nconsole.log(a);\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[e._v("分析bundle")])]),e._v(" "),a("img",{attrs:{src:s(392)}}),e._v("\n看出这个是一个匿名函数， 参数是一个对象，也可以看出这个对象就是我们想要打包的文件，key是路径，value是这个文件的函数\n"),a("br"),e._v(" \n那么这个函数内有执行来什么操作呢？\n"),a("br"),e._v(" "),a("img",{attrs:{src:s(393)}}),e._v("\n 这个函数有变量（installedModules）来缓存module，这个对象存储的module也是个对象，有i（moduleId）l（是否被加载）exports（代码）。\n这样webpack就能将匿名函数的所有参数（module）都放到了installedModules变量中，且输出module代码运行\n"),a("br"),e._v(" "),a("img",{attrs:{src:s(394)}}),e._v("\n这是这个匿名的return，它调用了内部的__webpack_require__函数，而__webpack_require__就是输出module代码，所以这就是定义了入口文件\n"),a("br"),e._v("\n定义了入口文件，那么来看看这个入口文件写了什么代码\n"),a("img",{attrs:{src:s(395)}}),e._v("\n可以看出其实它执行了__webpack_require__函数，来再加载别的module。\n"),a("br"),e._v("\n这就是基本一套webpack的打包运行机制。\n")])},[],!1,null,null,null);t.default=n.exports}}]);